PrimeCalc
=========

Приложения для нахождения простых чисел в заданном диапазоне и последующей генерацией из них заданного числа массивов простых чисел, таких что, среднее-арифметичское модулей разностей всех элементов массива максимально близка к заданному числу (+-1 от заданного числа).

=========

С первой задачей приложение справляется хорошо, шустро находит простые числа даже на больших диапазонах (в диапазоне от 1 до 1000000 нашел все числа примерно за 1 секунду *Окружение: Sony Xperia SP, Android 4.3, Qualcomm MSM8960T 1700 МГц 2 ядра, 
1 Гб ОЗУ*), использовался алгоритм решета Эртосфена.

Со второй задачей приложение справляется не всегда из-за не самой крепкой дружбы разработчика с математикой, но все же 
переодически справляется, и в этом есть свой плюс: вы можете проверить свою удачу!

Как говорилось выше, из-за бесплодных попыток вывести точную формулу для расчета, использовался эмпирический метод анализа, в ходе которого было установлено, что в подавляющем большинстве случаев если к формируемому массиву простых чисел, в конец добавить число равное или меньшее, чем последний элемент этого массива, то среднее-арифметическое модулей разностей всех элементов уменьшится, а если добавить большее число, то, соответственно, увеличится. Исходя из полученых знаний был составлен алгоритм.

Сам алгоритм:
****************************
Создаем ArrayList простых чисел из заданного диапазона - intArrayList;
Создаем пустой ArrayList, который будет хранить наш результат - rezArrayList;
Добавляем два элемента случайно выбранных из intArrayList в rezArrayList;
Вычисляем среднее-арифметическое для rezArrayList - result;

Цикл:
while (!(p-1 <= result <= p+1)){
Обнуляем сумму модулей разностей preresult;
Обнуляем счетчик разностей counter;

if(последний элемент в rezArrayList == последний элемент в intArrayList) 
  добавляем случайный элемент из intArrayList, кроме последнего;           //чтобы избежать бесконечного уменьшения result
else if(result >= p+1)
  добавляем случайный элемент из intArrayList, <= последний элемент в rezArrayList;
else if(result <= p-1)
  добавляем случайный элемент из intArrayList, > последний элемент в rezArrayList;
В цикле находим сумму модулей разностей всех элементов (сохраняем в preresult) и количество разностей (сохраняем в counter);
Вычисляем result = preresult/counter;
} конец цикла;

Преобразуем найденный массив в строку и передаем в переменую - resRandom;
Очищаем resArrayList для последующего использования;
Возвращаем пользователю resRandom;
*****************************

Теоретически, алгоритм, разработанный автором приложения для решения второй задачи, будет находить решение всегда, но в большом ряде случаев на это потребуется весьма длительное время из-за использования случайных значений.

Если приложение не выдает сгенерированные массивы, то советую отключить его, запустить и попробовать снова, если у вас много терпения и оперативки в телефоне)

